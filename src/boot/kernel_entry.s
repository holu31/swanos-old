# Объявиляем константы для мультизагрузочного заголовка. 
.set ALIGN,    1<<0             # выравниваем загруженные модули по границам страницы 
.set MEMINFO,  1<<1             # продоставляем карту памяти 
.set FLAGS,    ALIGN | MEMINFO  # это поле предоставляет флаг мультизагрузки 
.set MAGIC,    0x1BADB002       # магическое число позволяет загрузчику найти заголовок 
.set CHECKSUM, -(MAGIC + FLAGS) # контрольная сумма чтобы показать что код мультизагрузочный

# Объявить мультизагрузочный заголовок который отмечает программу как ядро. 
.section .multiboot.data, "aw"
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

# Выделить начальный стек. 
.section .bootstrap_stack, "aw", @nobits
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

# Предварительно выделить страницы, используемые для разбиения на страницы. Не программируйте адреса жестко и не предполагайте, что они 
# доступны, так как загрузчик мог загрузить 
# туда свои мультизагрузочные структуры или  модули. Это позволяет загрузчику знать, что он должен избегать адресов. 
.section .bss, "aw", @nobits
    .align 4096
boot_page_directory:
    .skip 4096
boot_page_table1:
    .skip 4096
# Если размер ядра превышает 3 МБ, могут потребоваться дополнительные таблицы страниц. 

# Точка входа в ядро. 
.section .multiboot.text, "a"
.global _start
.type _start, @function
_start:
    # Физический адрес boot_page_table1.
    movl $(boot_page_table1 - 0xC0000000), %edi

    # Первый адрес для сопоставления - это адрес 0. 
    movl $0, %esi
    
    # Отобразить 1023 страницы. 1024-й будет текстовым буфером VGA. 
    movl $1023, %ecx

1:
    # Отображение только ядра. 
    cmpl $_kernel_start, %esi
    jl 2f
    cmpl $(_kernel_end - 0xC0000000), %esi
    jge 3f

    # Сопоставьте физический адрес как "настоящий, доступный для записи". Обратите внимание, что это отображает 
    # .text и .rodata как доступные для записи. Помните о безопасности и отметьте их как недоступные для записи. 
    movl %esi, %edx
    orl $0x003, %edx
    movl %edx, (%edi)

2:
    # Размер страницы 4096 байт. 
    addl $4096, %esi

    # Размер записей в boot_page_table1 составляет 4 байта. 
    addl $4, %edi

    # Переходим к следующей записи, если мы еще не закончили. 
    loop 1b

3:
    # Отображение видеопамяти VGA в 0xC03FF000 как «настоящее, доступное для записи».
    movl $(0x000B8000 | 0x003), boot_page_table1 - 0xC0000000 + 1023 * 4

    # Таблица страниц используется для обеих записей каталога страниц 0 (практически с 0x0
    # на 0x3FFFFF) (таким образом, идентичность отображает ядро) и запись каталога страниц 
    # 768 (фактически от 0xC0000000 до 0xC03FFFFF) (таким образом, отображая ее в 
    # верхней половине ). Ядро привязано к идентичности, потому что включение подкачки 
    # не меняет следующую инструкцию, которая продолжает оставаться физической. 
    # Если не было сопоставления идентификаторов, CPU # вместо этого выдает ошибку страницы. 

    # Сопоставьте таблицу страниц с обоими виртуальными адресами 0x00000000 и 0xC0000000. 
    movl $(boot_page_table1 - 0xC0000000 + 0x003), boot_page_directory - 0xC0000000 + 0
    movl $(boot_page_table1 - 0xC0000000 + 0x003), boot_page_directory - 0xC0000000 + 768 * 4

    # Установите cr3 на адрес boot_page_directory. 
    movl $(boot_page_directory - 0xC0000000), %ecx
    movl %ecx, %cr3

    # Разрешить разбиение на страницы и бит защиты от записи.
    movl %cr0, %ecx
    orl $0x80010000, %ecx
    movl %ecx, %cr0

    # Переход на higher half с абсолютным прыжком. 
    lea 4f, %ecx
    jmp *%ecx

.section .text

4:
    # На этом этапе подкачка полностью настроена и включена. 

    # Отмените отображение идентификатора, поскольку теперь в нем нет необходимости.  
    movl $0, boot_page_directory + 0

    # Перезагрузите crc3, чтобы принудительно очистить TLB, чтобы изменения вступили в силу. 
    movl %cr3, %ecx
    movl %ecx, %cr3

    # Настраиваем стек.
    mov $stack_top, %esp

    # Открытие ядра.
    call kernel_main

    # Ой все))
    cli
1:	hlt
    # Отключение ОС